/**
 * GitHub Export Service
 * Pushes generated UI code directly to GitHub repositories
 */

import { Octokit } from "@octokit/rest";

export interface GitHubExportOptions {
  token: string; // GitHub personal access token
  owner: string; // GitHub username
  repo: string; // Repository name
  branch?: string; // Target branch (defaults to main)
  createRepo?: boolean; // Auto-create repo if doesn't exist
  commitMessage?: string;
  author?: {
    name: string;
    email: string;
  };
}

export interface GitHubExportResult {
  repoUrl: string;
  commitSha: string;
  files: string[];
  branch: string;
  timestamp: string;
}

/**
 * Export generated code to GitHub
 */
export async function exportToGitHub(
  code: string,
  tailwindConfig: string | undefined,
  options: GitHubExportOptions
): Promise<GitHubExportResult> {
  if (!options.token) {
    throw new Error("GitHub token required");
  }

  const octokit = new Octokit({ auth: options.token });
  const branch = options.branch || "main";
  const timestamp = new Date().toISOString();

  try {
    // Check if repo exists
    try {
      await octokit.repos.get({
        owner: options.owner,
        repo: options.repo,
      });
    } catch (error: any) {
      if (error.status === 404 && options.createRepo) {
        // Create repo
        await octokit.repos.createForAuthenticatedUser({
          name: options.repo,
          description: `AI-generated design - ${timestamp}`,
          private: false,
          auto_init: true,
        });
      } else {
        throw error;
      }
    }

    // Get latest commit on branch
    const { data: ref } = await octokit.git.getRef({
      owner: options.owner,
      repo: options.repo,
      ref: `heads/${branch}`,
    });

    const latestCommitSha = ref.object.sha;

    // Get tree of latest commit
    const { data: commit } = await octokit.git.getCommit({
      owner: options.owner,
      repo: options.repo,
      commit_sha: latestCommitSha,
    });

    // Create new tree with generated files
    const files: {
      path: string;
      mode: "100644" | "100755" | "120000";
      type: "blob" | "tree" | "commit";
      content?: string;
    }[] = [];

    files.push({
      path: "app.tsx",
      mode: "100644",
      type: "blob",
      content: code,
    });

    if (tailwindConfig) {
      files.push({
        path: "tailwind.config.ts",
        mode: "100644",
        type: "blob",
        content: tailwindConfig,
      });
    }

    files.push({
      path: "README.md",
      mode: "100644",
      type: "blob",
      content: generateReadme(timestamp),
    });

    files.push({
      path: "package.json",
      mode: "100644",
      type: "blob",
      content: generatePackageJson(),
    });

    const { data: newTree } = await octokit.git.createTree({
      owner: options.owner,
      repo: options.repo,
      tree: files as any,
      base_tree: commit.tree.sha,
    });

    // Create new commit
    const { data: newCommit } = await octokit.git.createCommit({
      owner: options.owner,
      repo: options.repo,
      tree: newTree.sha,
      message:
        options.commitMessage || `feat: AI-generated design - ${timestamp}`,
      parents: [latestCommitSha],
      author: {
        name: options.author?.name || "Synthex Design Studio",
        email: options.author?.email || "design@synthex.ai",
        date: timestamp,
      },
      committer: {
        name: options.author?.name || "Synthex Design Studio",
        email: options.author?.email || "design@synthex.ai",
        date: timestamp,
      },
    });

    // Update ref to point to new commit
    await octokit.git.updateRef({
      owner: options.owner,
      repo: options.repo,
      ref: `heads/${branch}`,
      sha: newCommit.sha,
    });

    return {
      repoUrl: `https://github.com/${options.owner}/${options.repo}`,
      commitSha: newCommit.sha,
      files: files.map((f) => f.path),
      branch,
      timestamp,
    };
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`GitHub export failed: ${error.message}`);
    }
    throw error;
  }
}

/**
 * Generate README for exported design
 */
function generateReadme(timestamp: string): string {
  return `# AI-Generated Design

Generated by Synthex Design Studio powered by Gemini 3 Pro.

**Generated**: ${timestamp}

## Features

- Responsive design with Tailwind CSS
- TypeScript with strict mode
- Accessibility compliant (WCAG 2.1 AA)
- Modern React 19+ components

## Setup

\`\`\`bash
npm install
npm run dev
\`\`\`

## Development

This design was generated from a natural language prompt using AI. All code is production-ready and follows React best practices.

### File Structure

- \`app.tsx\` - Main component
- \`tailwind.config.ts\` - Tailwind configuration
- \`package.json\` - Dependencies

## Deployment

Deploy to Vercel with one click:

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/${process.env.GITHUB_OWNER || "your-username"}/${process.env.GITHUB_REPO || "repo-name"})

## License

MIT
`;
}

/**
 * Generate package.json for exported design
 */
function generatePackageJson(): string {
  return JSON.stringify(
    {
      name: "synthex-design",
      version: "1.0.0",
      description: "AI-generated design with Synthex Design Studio",
      scripts: {
        dev: "next dev",
        build: "next build",
        start: "next start",
        lint: "next lint",
      },
      dependencies: {
        react: "^19.0.0",
        "react-dom": "^19.0.0",
        next: "^15.0.0",
      },
      devDependencies: {
        "@types/react": "^19.0.0",
        "@types/react-dom": "^19.0.0",
        "@types/node": "^20.0.0",
        typescript: "^5.0.0",
        "tailwindcss": "^3.4.0",
        "postcss": "^8.4.0",
        autoprefixer: "^10.4.0",
      },
    },
    null,
    2
  );
}

/**
 * Validate GitHub credentials
 */
export async function validateGitHubToken(token: string): Promise<boolean> {
  try {
    const octokit = new Octokit({ auth: token });
    await octokit.users.getAuthenticated();
    return true;
  } catch (error) {
    return false;
  }
}
