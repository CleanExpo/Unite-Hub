# Phase 28 - Public Copy, Template & Export Sanitisation Engine

**Date**: 2025-11-21
**Status**: Implementation Ready
**Branch**: `feature/phase28-public-copy-sanitiser`

## Executive Summary

Phase 28 implements the Public Copy Sanitisation Engine that ensures all public-facing text, templates, and exports are sanitized from vendor/model references. The engine automatically detects banned terms, replaces them with neutral phrases, and logs all sanitisation actions for compliance tracking.

## Hard Requirements

| Requirement | Value |
|-------------|-------|
| Sanitize All Public Copy | Yes |
| Block Banned Terms | Yes |
| Log Violations | Yes |
| CI Enforcement | Yes |

## Banned Public Terms

```typescript
const BANNED_PUBLIC_TERMS = [
  'Gemini',
  'Google Gemini',
  'Nano Banana',
  'Nano Banana 2',
  'gemini-3-pro-image-preview',
  'Google GenAI',
  'Google AI Studio',
  'DataForSEO',
  'Jina AI',
  'Anthropic',
  'Claude',
  'OpenAI',
  'DALL-E',
  'Midjourney',
  'Stable Diffusion',
];
```

## Database Schema

### Migration 083: Template Sanitisation Logs

```sql
-- 083_template_sanitisation_logs.sql

CREATE TABLE IF NOT EXISTS template_sanitisation_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  org_id UUID NOT NULL,
  template_name TEXT NOT NULL,
  location TEXT NOT NULL,
  detected_term TEXT NOT NULL,
  replacement TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),

  -- Foreign key
  CONSTRAINT template_sanitisation_logs_org_fk
    FOREIGN KEY (org_id) REFERENCES organizations(id) ON DELETE CASCADE
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_template_logs_org ON template_sanitisation_logs(org_id);
CREATE INDEX IF NOT EXISTS idx_template_logs_term ON template_sanitisation_logs(detected_term);
CREATE INDEX IF NOT EXISTS idx_template_logs_created ON template_sanitisation_logs(created_at DESC);

-- Enable RLS
ALTER TABLE template_sanitisation_logs ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY template_sanitisation_logs_select ON template_sanitisation_logs
  FOR SELECT TO authenticated
  USING (org_id IN (
    SELECT org_id FROM user_organizations WHERE user_id = auth.uid()
  ));

CREATE POLICY template_sanitisation_logs_insert ON template_sanitisation_logs
  FOR INSERT TO authenticated
  WITH CHECK (org_id IN (
    SELECT org_id FROM user_organizations WHERE user_id = auth.uid()
  ));

-- Comment
COMMENT ON TABLE template_sanitisation_logs IS 'Tracks when public copy or templates are auto-sanitised (Phase 28)';
```

## API Endpoints

### POST /api/sanitiser/scan-text

Scan text for banned terms and return sanitised version.

```typescript
// Request
{
  "text": "This image was generated by Gemini AI",
  "context": "email_template",
  "templateName": "welcome_email"
}

// Response
{
  "success": true,
  "sanitised": "This image was generated by our AI-powered system",
  "termsFound": 1,
  "replacements": [
    { "term": "Gemini AI", "replacement": "our AI-powered system" }
  ]
}
```

### POST /api/sanitiser/scan-template

Scan an entire template for banned terms.

```typescript
// Request
{
  "templateId": "uuid",
  "templateType": "email" | "report" | "pdf"
}

// Response
{
  "success": true,
  "templateId": "uuid",
  "totalReplacements": 3,
  "sanitised": true,
  "logs": [
    { "location": "subject", "term": "Claude", "replacement": "our AI assistant" },
    { "location": "body", "term": "OpenAI", "replacement": "our AI provider" }
  ]
}
```

### Implementation

```typescript
// src/app/api/sanitiser/scan-text/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseServer } from '@/lib/supabase';
import { TextSanitiser } from '@/lib/sanitiser/text-sanitiser';

export async function POST(req: NextRequest) {
  try {
    const { text, context, templateName } = await req.json();

    if (!text) {
      return NextResponse.json({ error: 'Missing text parameter' }, { status: 400 });
    }

    const supabase = await getSupabaseServer();

    // Get user and org
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get org
    const { data: userOrg } = await supabase
      .from('user_organizations')
      .select('org_id')
      .eq('user_id', user.id)
      .single();

    if (!userOrg) {
      return NextResponse.json({ error: 'No organization found' }, { status: 400 });
    }

    // Sanitise text
    const sanitiser = new TextSanitiser();
    const result = sanitiser.sanitise(text);

    // Log replacements
    if (result.replacements.length > 0 && templateName) {
      const logs = result.replacements.map(r => ({
        org_id: userOrg.org_id,
        template_name: templateName,
        location: context || 'unknown',
        detected_term: r.term,
        replacement: r.replacement,
      }));

      await supabase.from('template_sanitisation_logs').insert(logs);
    }

    return NextResponse.json({
      success: true,
      sanitised: result.sanitised,
      termsFound: result.replacements.length,
      replacements: result.replacements,
    });

  } catch (error) {
    console.error('Sanitiser error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

```typescript
// src/app/api/sanitiser/scan-template/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseServer } from '@/lib/supabase';
import { TemplateSanitiser } from '@/lib/sanitiser/template-sanitiser';

export async function POST(req: NextRequest) {
  try {
    const { templateId, templateType } = await req.json();

    if (!templateId || !templateType) {
      return NextResponse.json({ error: 'Missing parameters' }, { status: 400 });
    }

    const supabase = await getSupabaseServer();

    // Get user and org
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get org
    const { data: userOrg } = await supabase
      .from('user_organizations')
      .select('org_id')
      .eq('user_id', user.id)
      .single();

    if (!userOrg) {
      return NextResponse.json({ error: 'No organization found' }, { status: 400 });
    }

    // Get template based on type
    const templateTable = getTemplateTable(templateType);
    const { data: template, error } = await supabase
      .from(templateTable)
      .select('*')
      .eq('id', templateId)
      .single();

    if (error || !template) {
      return NextResponse.json({ error: 'Template not found' }, { status: 404 });
    }

    // Sanitise template
    const sanitiser = new TemplateSanitiser();
    const result = await sanitiser.sanitiseTemplate(template, templateType);

    // Log all replacements
    if (result.logs.length > 0) {
      const logEntries = result.logs.map(log => ({
        org_id: userOrg.org_id,
        template_name: template.name || templateId,
        location: log.location,
        detected_term: log.term,
        replacement: log.replacement,
      }));

      await supabase.from('template_sanitisation_logs').insert(logEntries);
    }

    // Update template with sanitised content
    await supabase
      .from(templateTable)
      .update(result.sanitisedTemplate)
      .eq('id', templateId);

    return NextResponse.json({
      success: true,
      templateId,
      totalReplacements: result.logs.length,
      sanitised: true,
      logs: result.logs,
    });

  } catch (error) {
    console.error('Template sanitiser error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

function getTemplateTable(templateType: string): string {
  const tables: Record<string, string> = {
    email: 'email_templates',
    report: 'report_templates',
    pdf: 'pdf_templates',
  };
  return tables[templateType] || 'templates';
}
```

## Sanitiser Service

```typescript
// src/lib/sanitiser/text-sanitiser.ts

const BANNED_PUBLIC_TERMS = [
  'Gemini',
  'Google Gemini',
  'Nano Banana',
  'Nano Banana 2',
  'gemini-3-pro-image-preview',
  'Google GenAI',
  'Google AI Studio',
  'DataForSEO',
  'Jina AI',
  'Anthropic',
  'Claude',
  'OpenAI',
  'DALL-E',
  'Midjourney',
  'Stable Diffusion',
];

const REPLACEMENT_MAP: Record<string, string> = {
  'gemini': 'our AI-powered system',
  'google gemini': 'our AI-powered system',
  'nano banana': 'our image generation system',
  'nano banana 2': 'our image generation system',
  'gemini-3-pro-image-preview': 'our image AI',
  'google genai': 'our AI provider',
  'google ai studio': 'our AI platform',
  'dataforseo': 'our SEO data provider',
  'jina ai': 'our search AI',
  'anthropic': 'our AI provider',
  'claude': 'our AI assistant',
  'openai': 'our AI provider',
  'dall-e': 'our image AI',
  'midjourney': 'our image AI',
  'stable diffusion': 'our image AI',
};

export class TextSanitiser {
  sanitise(text: string): SanitiseResult {
    let sanitised = text;
    const replacements: Replacement[] = [];

    for (const term of BANNED_PUBLIC_TERMS) {
      const regex = new RegExp(term, 'gi');
      const matches = text.match(regex);

      if (matches) {
        const replacement = REPLACEMENT_MAP[term.toLowerCase()] || 'our system';
        sanitised = sanitised.replace(regex, replacement);

        replacements.push({
          term,
          replacement,
          count: matches.length,
        });
      }
    }

    return { sanitised, replacements };
  }

  containsBannedTerms(text: string): boolean {
    const lowerText = text.toLowerCase();
    return BANNED_PUBLIC_TERMS.some(term =>
      lowerText.includes(term.toLowerCase())
    );
  }

  getBannedTerms(text: string): string[] {
    const lowerText = text.toLowerCase();
    return BANNED_PUBLIC_TERMS.filter(term =>
      lowerText.includes(term.toLowerCase())
    );
  }
}

interface SanitiseResult {
  sanitised: string;
  replacements: Replacement[];
}

interface Replacement {
  term: string;
  replacement: string;
  count?: number;
}

export { BANNED_PUBLIC_TERMS, REPLACEMENT_MAP };
```

```typescript
// src/lib/sanitiser/template-sanitiser.ts

import { TextSanitiser } from './text-sanitiser';

export class TemplateSanitiser {
  private textSanitiser: TextSanitiser;

  constructor() {
    this.textSanitiser = new TextSanitiser();
  }

  async sanitiseTemplate(template: any, templateType: string): Promise<TemplateResult> {
    const logs: SanitisationLog[] = [];
    const sanitisedTemplate = { ...template };

    // Get fields to sanitise based on template type
    const fields = this.getFieldsToSanitise(templateType);

    for (const field of fields) {
      if (template[field] && typeof template[field] === 'string') {
        const result = this.textSanitiser.sanitise(template[field]);

        if (result.replacements.length > 0) {
          sanitisedTemplate[field] = result.sanitised;

          for (const r of result.replacements) {
            logs.push({
              location: field,
              term: r.term,
              replacement: r.replacement,
            });
          }
        }
      }
    }

    return { sanitisedTemplate, logs };
  }

  private getFieldsToSanitise(templateType: string): string[] {
    const fieldMap: Record<string, string[]> = {
      email: ['subject', 'body', 'preview_text', 'footer'],
      report: ['title', 'summary', 'content', 'header', 'footer'],
      pdf: ['title', 'header', 'footer', 'content', 'watermark'],
    };

    return fieldMap[templateType] || ['content'];
  }
}

interface TemplateResult {
  sanitisedTemplate: any;
  logs: SanitisationLog[];
}

interface SanitisationLog {
  location: string;
  term: string;
  replacement: string;
}
```

## UI Components

### SanitisationPreviewBanner

```typescript
// src/components/admin/SanitisationPreviewBanner.tsx

'use client';

import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { AlertTriangle, Shield } from 'lucide-react';

interface SanitisationPreviewBannerProps {
  termsFound: number;
  replacements: Array<{ term: string; replacement: string }>;
}

export function SanitisationPreviewBanner({
  termsFound,
  replacements,
}: SanitisationPreviewBannerProps) {
  if (termsFound === 0) {
    return (
      <Alert className="bg-green-50 border-green-200">
        <Shield className="h-4 w-4 text-green-600" />
        <AlertTitle className="text-green-800">Content Safe</AlertTitle>
        <AlertDescription className="text-green-700">
          No vendor terms detected. Content is safe for public use.
        </AlertDescription>
      </Alert>
    );
  }

  return (
    <Alert className="bg-yellow-50 border-yellow-200">
      <AlertTriangle className="h-4 w-4 text-yellow-600" />
      <AlertTitle className="text-yellow-800">
        {termsFound} term{termsFound > 1 ? 's' : ''} sanitised
      </AlertTitle>
      <AlertDescription className="text-yellow-700">
        <p className="mb-2">The following terms were automatically replaced:</p>
        <ul className="list-disc list-inside space-y-1">
          {replacements.map((r, i) => (
            <li key={i}>
              <span className="line-through text-red-600">{r.term}</span>
              {' â†’ '}
              <span className="text-green-600">{r.replacement}</span>
            </li>
          ))}
        </ul>
      </AlertDescription>
    </Alert>
  );
}
```

### SanitisationWarningTag

```typescript
// src/components/admin/SanitisationWarningTag.tsx

'use client';

import { Badge } from '@/components/ui/badge';
import { AlertTriangle, Check } from 'lucide-react';

interface SanitisationWarningTagProps {
  hasBannedTerms: boolean;
  termCount?: number;
}

export function SanitisationWarningTag({
  hasBannedTerms,
  termCount = 0,
}: SanitisationWarningTagProps) {
  if (!hasBannedTerms) {
    return (
      <Badge variant="outline" className="bg-green-50 text-green-700 border-green-300">
        <Check className="w-3 h-3 mr-1" />
        Clean
      </Badge>
    );
  }

  return (
    <Badge variant="outline" className="bg-yellow-50 text-yellow-700 border-yellow-300">
      <AlertTriangle className="w-3 h-3 mr-1" />
      {termCount} term{termCount > 1 ? 's' : ''} found
    </Badge>
  );
}
```

## Template Editor Integration

```typescript
// src/components/admin/templates/TemplateEditor.tsx (integration example)

'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { SanitisationPreviewBanner } from '@/components/admin/SanitisationPreviewBanner';
import { useAuth } from '@/contexts/AuthContext';

interface TemplateEditorProps {
  templateId: string;
  initialContent: string;
  templateType: 'email' | 'report' | 'pdf';
  onSave: (content: string) => void;
}

export function TemplateEditor({
  templateId,
  initialContent,
  templateType,
  onSave,
}: TemplateEditorProps) {
  const { session } = useAuth();
  const [content, setContent] = useState(initialContent);
  const [sanitiseResult, setSanitiseResult] = useState<any>(null);
  const [saving, setSaving] = useState(false);

  const handleSave = async () => {
    setSaving(true);

    // First sanitise
    const response = await fetch('/api/sanitiser/scan-text', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${session?.access_token}`,
      },
      body: JSON.stringify({
        text: content,
        context: templateType,
        templateName: templateId,
      }),
    });

    const result = await response.json();
    setSanitiseResult(result);

    // Save sanitised content
    if (result.success) {
      setContent(result.sanitised);
      onSave(result.sanitised);
    }

    setSaving(false);
  };

  return (
    <div className="space-y-4">
      {sanitiseResult && (
        <SanitisationPreviewBanner
          termsFound={sanitiseResult.termsFound}
          replacements={sanitiseResult.replacements}
        />
      )}

      <Textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        rows={10}
        className="font-mono"
      />

      <Button onClick={handleSave} disabled={saving}>
        {saving ? 'Sanitising & Saving...' : 'Save Template'}
      </Button>
    </div>
  );
}
```

## Agent Integration

### Orchestrator Must Call Sanitiser

```typescript
// Example: Email template agent must sanitise before saving

export class EmailTemplateAgent {
  async saveTemplate(templateData: TemplateData): Promise<SaveResult> {
    // MANDATORY: Sanitise before saving
    const sanitiseResponse = await fetch('/api/sanitiser/scan-template', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        templateId: templateData.id,
        templateType: 'email',
      }),
    });

    const sanitiseResult = await sanitiseResponse.json();

    if (!sanitiseResult.success) {
      throw new Error('Failed to sanitise template');
    }

    // Log sanitisation in agent memory
    if (sanitiseResult.totalReplacements > 0) {
      await this.logAction('sanitised_template', {
        templateId: templateData.id,
        replacements: sanitiseResult.totalReplacements,
      });
    }

    return { success: true, sanitised: true };
  }
}
```

## CI Enforcement

```typescript
// tests/ci/sanitisation-enforcement.test.ts

import { TextSanitiser, BANNED_PUBLIC_TERMS } from '@/lib/sanitiser/text-sanitiser';

describe('Sanitisation CI Enforcement', () => {
  const sanitiser = new TextSanitiser();

  test('no banned terms in fixture files', async () => {
    const fixtures = await loadAllFixtures();

    for (const fixture of fixtures) {
      const content = JSON.stringify(fixture);
      const bannedTerms = sanitiser.getBannedTerms(content);

      expect(bannedTerms).toEqual([]);
    }
  });

  test('no banned terms in test templates', async () => {
    const templates = await loadTestTemplates();

    for (const template of templates) {
      for (const field of ['subject', 'body', 'content']) {
        if (template[field]) {
          const hasBanned = sanitiser.containsBannedTerms(template[field]);
          expect(hasBanned).toBe(false);
        }
      }
    }
  });

  test('sanitiser replaces all banned terms', () => {
    for (const term of BANNED_PUBLIC_TERMS) {
      const text = `This is ${term} content`;
      const result = sanitiser.sanitise(text);

      expect(result.sanitised.toLowerCase()).not.toContain(term.toLowerCase());
      expect(result.replacements.length).toBeGreaterThan(0);
    }
  });

  test('sanitiser preserves safe content', () => {
    const safeText = 'This is safe content with no vendor terms';
    const result = sanitiser.sanitise(safeText);

    expect(result.sanitised).toBe(safeText);
    expect(result.replacements.length).toBe(0);
  });
});

async function loadAllFixtures(): Promise<any[]> {
  // Implementation to load all fixture files
  return [];
}

async function loadTestTemplates(): Promise<any[]> {
  // Implementation to load test templates
  return [];
}
```

## Export Pre-Send Scanning

```typescript
// src/lib/export/pre-send-scanner.ts

import { TextSanitiser } from '@/lib/sanitiser/text-sanitiser';

export async function scanExportBeforeSend(
  exportData: ExportData
): Promise<ScanResult> {
  const sanitiser = new TextSanitiser();
  const issues: Issue[] = [];

  // Scan all text fields
  const fieldsToScan = ['title', 'content', 'summary', 'footer', 'header'];

  for (const field of fieldsToScan) {
    if (exportData[field]) {
      if (sanitiser.containsBannedTerms(exportData[field])) {
        const terms = sanitiser.getBannedTerms(exportData[field]);
        issues.push({
          field,
          terms,
          severity: 'error',
        });
      }
    }
  }

  if (issues.length > 0) {
    return {
      safe: false,
      issues,
      message: 'Export contains banned terms and cannot be sent',
    };
  }

  return {
    safe: true,
    issues: [],
    message: 'Export is safe for sending',
  };
}

interface ExportData {
  [key: string]: string;
}

interface Issue {
  field: string;
  terms: string[];
  severity: 'warning' | 'error';
}

interface ScanResult {
  safe: boolean;
  issues: Issue[];
  message: string;
}
```

## Implementation Tasks

### T1: Implement Text Sanitiser Module

- [ ] Create shared sanitiser utility
- [ ] Implement banned term detection
- [ ] Implement safe replacement mapping
- [ ] Add case-insensitive matching

### T2: Wire Sanitiser into Template Save Flows

- [ ] Hook into email template save
- [ ] Hook into report template save
- [ ] Hook into PDF header/footer generation
- [ ] Add pre-send scanning for exports

### T3: Add CI Checks

- [ ] Scan fixture texts
- [ ] Scan test templates
- [ ] Fail build if banned terms detected
- [ ] Add to pre-commit hooks

## Completion Definition

Phase 28 is complete when:

1. **All public templates sanitised**: No banned terms in saved templates
2. **Exports blocked if unsafe**: Pre-send scanning prevents violations
3. **Logs written**: All sanitisation actions tracked in database
4. **CI enforcement**: Build fails on unsanitised fixtures
5. **Agents comply**: All agents call sanitiser before saving

---

*Phase 28 - Public Copy Sanitisation Engine Complete*
*Unite-Hub Status: VENDOR-NEUTRAL COPY ENFORCED*
